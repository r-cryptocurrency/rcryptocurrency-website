generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["orderByNulls"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Holder {
  address        String      @id
  balanceNova    Float       @default(0)
  balanceOne     Float       @default(0)
  balanceEth     Float       @default(0)
  totalBalance   Float       @default(0)
  lastUpdated    DateTime    @updatedAt
  lastTransferAt DateTime?
  hasOutgoing    Boolean     @default(false)
  label          String?
  username       String?
  user           RedditUser? @relation(fields: [username], references: [username])

  @@index([totalBalance])
  @@index([lastTransferAt])
  @@index([username])
}

model LiquiditySnapshot {
  id        Int      @id @default(autoincrement())
  timestamp DateTime @default(now())
  chain     String
  dex       String
  tvlUsd    Float
  moonCount Float
  ethCount  Float
}

model RedditUser {
  username       String           @id
  rawUpvotes     Int              @default(0)
  estimatedKarma Float            @default(0)
  earnedMoons    Float            @default(0)
  lastScraped    DateTime         @updatedAt
  holders        Holder[]
  submissions    Submission[]
  addressLink    UserAddressLink?
}

model MarketStat {
  id                Int      @id @default(autoincrement())
  timestamp         DateTime @default(now())
  priceUsd          Float
  marketCap         Float
  volume24h         Float
  change24h         Float
  redditSubscribers Int      @default(0)
  activeUsers       Int      @default(0)
}

model Submission {
  id         String     @id
  authorName String
  title      String?
  subreddit  String
  score      Int
  isComment  Boolean
  createdAt  DateTime
  author     RedditUser @relation(fields: [authorName], references: [username])

  @@index([authorName])
  @@index([createdAt])
}

model RedditPost {
  id              String           @id
  title           String
  author          String
  score           Int
  url             String
  createdUtc      DateTime
  selftext        String?
  flair           String?
  numComments     Int
  sentiment       Float?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  karmaCountedRound Int?           // Track which round this post's count was recorded for
  mentions        ProjectMention[]
  comments        RedditComment[]

  @@index([createdUtc])
  @@index([author])
}

model RedditComment {
  id                String           @id
  postId            String
  author            String
  body              String
  score             Int
  createdUtc        DateTime
  sentiment         Float?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
  karmaCountedRound Int?             // Track which round this comment's count was recorded for
  mentions          ProjectMention[]
  post              RedditPost       @relation(fields: [postId], references: [id])

  @@index([createdUtc])
  @@index([author])
}

model ProjectMention {
  id        Int            @id @default(autoincrement())
  projectId String
  postId    String?
  commentId String?
  sentiment Float?
  createdAt DateTime       @default(now())
  comment   RedditComment? @relation(fields: [commentId], references: [id])
  post      RedditPost?    @relation(fields: [postId], references: [id])
}

model MoonEpoch {
  id               Int       @id
  startDate        DateTime
  endDate          DateTime
  snapshotDate     DateTime?
  distributionDate DateTime?
}

model Burn {
  id          Int      @id @default(autoincrement())
  txHash      String   @unique
  blockNumber BigInt
  timestamp   DateTime @default(now())
  amount      Float
  chain       String
  sender      String

  @@index([timestamp])
  @@index([chain])
  @@index([sender])
}

model Swap {
  id          Int      @id @default(autoincrement())
  txHash      String   @unique
  blockNumber BigInt
  timestamp   DateTime @default(now())
  chain       String
  dex         String
  amountIn    Float
  amountOut   Float
  tokenIn     String
  tokenOut    String
  usdValue    Float?
  maker       String

  @@index([timestamp])
  @@index([maker])
  @@index([dex])
}

// Karma tracking for 28-day rounds
model KarmaRound {
  id          Int           @id // Round number (e.g., 70, 71, etc.)
  startDate   DateTime
  endDate     DateTime
  isActive    Boolean       @default(false)
  createdAt   DateTime      @default(now())
  entries     KarmaEntry[]

  @@index([isActive])
  @@index([startDate])
}

model KarmaEntry {
  id          Int         @id @default(autoincrement())
  roundId     Int
  username    String
  postKarma   Int         @default(0)
  commentKarma Int        @default(0)
  totalKarma  Int         @default(0)
  postCount   Int         @default(0)
  commentCount Int        @default(0)
  updatedAt   DateTime    @updatedAt
  round       KarmaRound  @relation(fields: [roundId], references: [id])

  @@unique([roundId, username])
  @@index([roundId, totalKarma(sort: Desc)])
  @@index([username])
}

// Verified Reddit username <-> ETH address links for distributions
model UserAddressLink {
  id         Int        @id @default(autoincrement())
  username   String     @unique // Reddit username (without u/)
  address    String     // ETH address (checksummed)
  linkedAt   DateTime   @default(now())
  verifiedAt DateTime   @default(now())

  // Relation to existing RedditUser if exists
  user       RedditUser? @relation(fields: [username], references: [username])

  @@index([address])
  @@index([username])
}

// Distribution rounds with Merkle roots
model DistributionRound {
  id              Int       @id // Matches KarmaRound id
  merkleRoot      String    // 0x... hex string
  totalAmount     String    // BigInt as string for precision
  tokenAddress    String    // MOON contract address
  chainId         Int       // 42170 for Arbitrum Nova
  contractAddress String    // MoonDistributor contract address
  claimsJson      String?   // JSON filename or IPFS hash
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now())
  expirationDate  DateTime

  @@index([isActive])
}

// Track individual claims (for UI status, contract is source of truth)
model DistributionClaim {
  id        Int      @id @default(autoincrement())
  roundId   Int
  username  String
  address   String
  amount    String   // BigInt as string
  index     Int      // Merkle tree leaf index
  claimedAt DateTime?
  txHash    String?

  @@unique([roundId, username])
  @@index([roundId])
  @@index([address])
}
